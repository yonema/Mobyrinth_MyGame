★オブジェクトを作成するときにすること
●命名規則
○クラス名
・反転オブジェクトのとき
ROオブジェクト名１_オブジェクト名２
※オブジェクト名１、オブジェクト名２のスペルは最初は大文字、後は小文字
・障害オブジェクトのとき
OOオブジェクト名
※オブジェクト名のスペルは最初は大文字、後は小文字
○オブジェクトのクラス名→オブジェクトのクラス名を書く。
○オブジェクトの名前→オブジェクトのクラス名の「RO」もしくは「OO」を消した形で書く。
○オブジェクトの名前１→オブジェクトのクラス名のアンダーバーの前半のスペルを書く。
○オブジェクトの名前２→オブジェクトのクラス名のアンダーバーの後半のスペルを書く。
※オブジェクトの名前、オブジェクトの名前１、オブジェクトの名前２のスペルは、すべて小文字


●ヘッダーファイル
※命名規則
・反転オブジェクトのとき
ROオブジェクトの名前１_オブジェクトの名前２.h
・障害オブジェクトのとき
OOオブジェクトの名前.h

//ここからコピー
#include "ReversibleObject.h"
#include "OObigFire.h"

class クラス名 : public CReversibleObject
{
public:
	bool StartSub() override final;
	void QuerySub()override final;
private:

};


●ソースファイル
※命名規則
ヘッダーファイル名.cpp

//ここからコピー
#include "stdafx.h"
#include "ROmizu_kori.h"

bool クラス名::StartSub()
{
	Init("tkmファイル名", enum型の変数１,
		"tkmファイル名", enum型の変数２);

	return true;
}

void クラス名::QuerySub()
{
	const float hitDot = 0.005f; //オブジェクトが触れたかを判定する変数

	if (GetObjectType() == enum型の変数１)
	{
		//ここに処理を書く。
	}
	else if (GetObjectType() == enum型の変数２)
	{
		//ここに処理を書く。
	}
}


●LevelObjectBase.h
enum EnObjectTypeにオブジェクトの番号を追加
※命名規則
○enオブジェクトの名前
オブジェクトの名前→クラス名のそれぞれのオブジェクト名を書く。
※反転するオブジェクトはそれぞれ別に作る。


●StageBase.cpp
○void IStageBase::LoadLevel(const char* tklFilePath);
・反転オブジェクトのとき
else if (objData.EqualObjectName(L"オブジェクトの名前１") == true)
{
	オブジェクトのクラス名* RObject;
	RObject = NewGO<オブジェクトのクラス名>(0, "オブジェクトの名前");	
	RObject->SetPosition(objData.position);
	RObject->SetFrontOrBack(CReversibleObject::enFront);
	return true;
}
else if (objData.EqualObjectName(L"オブジェクトの名前２") == true)
{
	オブジェクトのクラス名* RObject;
	RObject = NewGO<オブジェクトのクラス名>(0, "オブジェクトの名前");
	RObject->SetPosition(objData.position);
	RObject->SetFrontOrBack(CReversibleObject::enBack);
	return true;
}

・障害オブジェクトのとき
else if (objData.EqualObjectName(L"オブジェクトの名前") == true)
{
	//ゴールはメンバ変数で保持しておく。
	m_goal = NewGO<オブジェクトのクラス名>(0, "オブジェクトの名前");
	m_goal->SetPosition(objData.position);
	return true;
}

○IStageBase::~IStageBase();
・反転オブジェクトのとき
QueryGOs<オブジェクトのクラス名>("オブジェクトの名前", [&](オブジェクトのクラス名* RObject)->bool
	{
		DeleteGO(RObject);
		return true;
	}
);

・障害オブジェクトのとき
QueryGOs<オブジェクトのクラス名>("オブジェクトの名前", [&](オブジェクトのクラス名* OObject)->bool
	{
		DeleteGO(OObject);
		return true;
	}
);